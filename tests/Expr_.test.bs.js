// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Expr from "../src/lib/core-next/Expr/Expr.bs.js";
import * as Zora from "zora";
import * as FormDNA from "../src/lib/core-next/Calc/FormDNA.bs.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";

var exprsCon = [
  {
    f: [],
    str: ""
  },
  {
    f: [
      {
        TAG: /* Uncl */3,
        _0: ""
      },
      {
        TAG: /* Uncl */3,
        _0: "üëÄ"
      }
    ],
    str: "///üëÄ/"
  },
  {
    f: [{
        TAG: /* FDna */5,
        _0: {
          dna: FormDNA.makeUnsafe([/* N */0]),
          form: undefined,
          vars: undefined
        }
      }],
    str: "[‚Åò0]"
  },
  {
    f: [{
        TAG: /* Mark */0,
        _0: [
          {
            TAG: /* Mark */0,
            _0: []
          },
          {
            TAG: /* Mark */0,
            _0: [
              {
                TAG: /* Mark */0,
                _0: [{
                    TAG: /* Mark */0,
                    _0: []
                  }]
              },
              {
                TAG: /* Mark */0,
                _0: []
              }
            ]
          }
        ]
      }],
    str: "(()((())()))"
  },
  {
    f: [
      {
        TAG: /* Mark */0,
        _0: []
      },
      {
        TAG: /* CVal */1,
        _0: /* U */1
      },
      {
        TAG: /* Uncl */3,
        _0: "√úber Ich"
      },
      {
        TAG: /* SeqRE */2,
        _0: {
          reEntryPar: /* Any */2,
          unmarked: true,
          interpr: /* RecIdent */1
        },
        _1: {
          hd: [{
              TAG: /* Mark */0,
              _0: [{
                  TAG: /* CVal */1,
                  _0: /* M */3
                }]
            }],
          tl: {
            hd: [],
            tl: /* [] */0
          }
        }
      },
      {
        TAG: /* FDna */5,
        _0: {
          dna: FormDNA.makeUnsafe([
                /* M */3,
                /* I */2,
                /* U */1,
                /* N */0
              ]),
          form: [{
              TAG: /* CVal */1,
              _0: /* M */3
            }],
          vars: undefined
        }
      }
    ],
    str: "()u/√úber Ich/{(m), _@'}[m‚Åò3210]"
  }
];

var exprsVar = [
  {
    f: [],
    str: ""
  },
  {
    f: [
      {
        TAG: /* Var */4,
        _0: "a"
      },
      {
        TAG: /* Var */4,
        _0: "Œª"
      },
      {
        TAG: /* Var */4,
        _0: "a_n"
      },
      {
        TAG: /* Var */4,
        _0: "apple"
      },
      {
        TAG: /* Var */4,
        _0: "s√º√üer_apfel b"
      }
    ],
    str: "aŒª\"a_n\"\"apple\"\"s√º√üer_apfel b\""
  }
];

Zora.test("Testing show()", (function (t) {
        exprsCon.forEach(function (expr) {
              t.test("given a constant [FORM], test for \"" + expr.str + "\"", (function (t) {
                      var input = expr.f;
                      var actual = Expr.FORM.show(undefined, input);
                      var expected = expr.str;
                      t.equal(actual, expected, "should be the formula \"" + expr.str + "\"");
                      
                    }));
              
            });
        exprsVar.forEach(function (expr) {
              t.test("given a variable [FORM], test for \"" + expr.str + "\"", (function (t) {
                      var input = expr.f;
                      var actual = Expr.FORM.show(undefined, input);
                      var expected = expr.str;
                      t.equal(actual, expected, "should be the formula \"" + expr.str + "\"");
                      
                    }));
              
            });
        
      }));

Zora.test("Testing FCON.toFVAR", (function (t) {
        t.test("given an empty [FCON] expression", (function (t) {
                var input = [];
                var actual = Expr.FCON.toFVAR(input);
                var expected = [];
                t.equal(actual, expected, "should be equivalent [FVAR]");
                
              }));
        t.test("given a complex [FCON] expression", (function (t) {
                var input = [
                  {
                    TAG: /* Mark */0,
                    _0: [
                      {
                        TAG: /* CVal */1,
                        _0: /* I */2
                      },
                      {
                        TAG: /* Mark */0,
                        _0: [{
                            TAG: /* Mark */0,
                            _0: [{
                                TAG: /* CVal */1,
                                _0: /* N */0
                              }]
                          }]
                      },
                      {
                        TAG: /* CVal */1,
                        _0: /* U */1
                      }
                    ]
                  },
                  {
                    TAG: /* SeqRE */2,
                    _0: {
                      reEntryPar: /* Even */0,
                      unmarked: false,
                      interpr: /* RecInstr */0
                    },
                    _1: {
                      hd: [{
                          TAG: /* Uncl */3,
                          _0: "Unklar"
                        }],
                      tl: /* [] */0
                    }
                  },
                  {
                    TAG: /* FDna */5,
                    _0: {
                      dna: FormDNA.makeUnsafe([/* N */0]),
                      form: [{
                          TAG: /* CVal */1,
                          _0: /* M */3
                        }],
                      vars: ["a"]
                    }
                  }
                ];
                var actual = Expr.FCON.toFVAR(input);
                var expected = [
                  {
                    TAG: /* Mark */0,
                    _0: [
                      {
                        TAG: /* CVal */1,
                        _0: /* I */2
                      },
                      {
                        TAG: /* Mark */0,
                        _0: [{
                            TAG: /* Mark */0,
                            _0: [{
                                TAG: /* CVal */1,
                                _0: /* N */0
                              }]
                          }]
                      },
                      {
                        TAG: /* CVal */1,
                        _0: /* U */1
                      }
                    ]
                  },
                  {
                    TAG: /* SeqRE */2,
                    _0: {
                      reEntryPar: /* Even */0,
                      unmarked: false,
                      interpr: /* RecInstr */0
                    },
                    _1: {
                      hd: [{
                          TAG: /* Uncl */3,
                          _0: "Unklar"
                        }],
                      tl: /* [] */0
                    }
                  },
                  {
                    TAG: /* FDna */5,
                    _0: {
                      dna: FormDNA.makeUnsafe([/* N */0]),
                      form: [{
                          TAG: /* CVal */1,
                          _0: /* M */3
                        }],
                      vars: ["a"]
                    }
                  }
                ];
                t.equal(actual, expected, "should be equivalent [FVAR]");
                
              }));
        
      }));

Zora.test("Testing FVAR.getVars()", (function (t) {
        t.test("given an empty [FVAR] expression", (function (t) {
                var input = [];
                var actual = Expr.FVAR.getVars(input);
                var expected = [];
                t.equal(actual, expected, "should be an empty array");
                
              }));
        t.test("given [FVAR] expression without variables", (function (t) {
                var input = [
                  {
                    TAG: /* Mark */0,
                    _0: [{
                        TAG: /* CVal */1,
                        _0: /* U */1
                      }]
                  },
                  {
                    TAG: /* Uncl */3,
                    _0: "Cthulu"
                  }
                ];
                var actual = Expr.FVAR.getVars(input);
                var expected = [];
                t.equal(actual, expected, "should be an empty array");
                
              }));
        t.test("given [FVAR] expression with 1 variable", (function (t) {
                var input = [
                  {
                    TAG: /* Mark */0,
                    _0: []
                  },
                  {
                    TAG: /* Mark */0,
                    _0: [{
                        TAG: /* Var */4,
                        _0: "a"
                      }]
                  },
                  {
                    TAG: /* CVal */1,
                    _0: /* M */3
                  }
                ];
                var actual = Expr.FVAR.getVars(input);
                var expected = ["a"];
                t.equal(actual, expected, "should be [\"a\"]");
                
              }));
        t.test("given [FVAR] expression with multiple variables", (function (t) {
                var input = [
                  {
                    TAG: /* Mark */0,
                    _0: [{
                        TAG: /* Mark */0,
                        _0: [{
                            TAG: /* Var */4,
                            _0: "Red"
                          }]
                      }]
                  },
                  {
                    TAG: /* Mark */0,
                    _0: [{
                        TAG: /* Var */4,
                        _0: "Blue"
                      }]
                  },
                  {
                    TAG: /* Var */4,
                    _0: "Green"
                  }
                ];
                var actual = Expr.FVAR.getVars(input);
                var expected = [
                  "Blue",
                  "Green",
                  "Red"
                ];
                t.equal(actual, expected, "should be variables [\"Blue\",\"Green\",\"Red\"] in alphabetic order");
                
              }));
        t.test("given [FVAR] expression with variables nested inside seqRE", (function (t) {
                var input = [{
                    TAG: /* SeqRE */2,
                    _0: {
                      reEntryPar: /* Odd */1,
                      unmarked: true,
                      interpr: /* RecInstr */0
                    },
                    _1: {
                      hd: [
                        {
                          TAG: /* Var */4,
                          _0: "M√§use"
                        },
                        {
                          TAG: /* SeqRE */2,
                          _0: {
                            reEntryPar: /* Odd */1,
                            unmarked: true,
                            interpr: /* RecInstr */0
                          },
                          _1: {
                            hd: [{
                                TAG: /* Var */4,
                                _0: "Ratten"
                              }],
                            tl: {
                              hd: [{
                                  TAG: /* Mark */0,
                                  _0: [{
                                      TAG: /* Var */4,
                                      _0: "W√ºrmer"
                                    }]
                                }],
                              tl: /* [] */0
                            }
                          }
                        }
                      ],
                      tl: /* [] */0
                    }
                  }];
                var actual = Expr.FVAR.getVars(input);
                var expected = [
                  "M√§use",
                  "Ratten",
                  "W√ºrmer"
                ];
                t.equal(actual, expected, "should be variables [\"M√§use\",\"Ratten\",\"W√ºrmer\"] in alphabetic order");
                
              }));
        t.test("given [FVAR] expression with variables nested inside fdna", (function (t) {
                var input = [{
                    TAG: /* FDna */5,
                    _0: {
                      dna: FormDNA.makeUnsafe([/* N */0]),
                      form: [
                        {
                          TAG: /* Var */4,
                          _0: "a"
                        },
                        {
                          TAG: /* Var */4,
                          _0: "b"
                        }
                      ],
                      vars: [
                        "a",
                        "b"
                      ]
                    }
                  }];
                var actual = Expr.FVAR.getVars(input);
                var expected = [];
                t.equal(actual, expected, "should be the empty array");
                
              }));
        
      }));

var dtrees = [
  {
    tree: Caml_array.get(Expr.DepthTree.testTrees, 0),
    form: [],
    str: "{ root, form: '', children: [] }"
  },
  {
    tree: Caml_array.get(Expr.DepthTree.testTrees, 1),
    form: [{
        TAG: /* CVal */1,
        _0: /* U */1
      }],
    str: "{ root, form: 'u', children: [{ index: 0, form: 'u' }] }"
  },
  {
    tree: Caml_array.get(Expr.DepthTree.testTrees, 2),
    form: [{
        TAG: /* Mark */0,
        _0: []
      }],
    str: "{ root, form: '()', children: [{ index: 0, form: '()', children: [] }] }"
  },
  {
    tree: Caml_array.get(Expr.DepthTree.testTrees, 3),
    form: [{
        TAG: /* Mark */0,
        _0: [
          {
            TAG: /* CVal */1,
            _0: /* M */3
          },
          {
            TAG: /* Mark */0,
            _0: []
          }
        ]
      }],
    str: "{ root, form: '(m())', children: [{ index: 0, form: '(m())', children: [{ index: 00, form: 'm' }, { index: 01, form: '()', children: [] }] }] }"
  }
];

Zora.test("Testing DepthTree.parse()", (function (t) {
        dtrees.forEach(function (input) {
              t.test("given a depth tree", (function (t) {
                      var actual = Expr.DepthTree.parse(input.form);
                      var expected = input.tree;
                      t.equal(actual, expected, "should be \"" + input.str + "\"");
                      
                    }));
              
            });
        
      }));

Zora.test("Testing DepthTree.show()", (function (t) {
        dtrees.forEach(function (input) {
              t.test("given a depth tree", (function (t) {
                      var actual = Expr.DepthTree.show(input.tree);
                      var expected = input.str;
                      t.equal(actual, expected, "should be \"" + input.str + "\"");
                      
                    }));
              
            });
        
      }));

Zora.test("Testing Sequence.toFORMt()", (function (t) {
        t.test("given an empty sequence", (function (t) {
                var actual = Expr.Sequence.toFORMt(/* [] */0);
                var expected = {
                  TAG: /* Mark */0,
                  _0: []
                };
                t.equal(actual, expected, "should be an empty Mark");
                
              }));
        t.test("given a singleton sequence", (function (t) {
                var input_0 = [];
                var input = {
                  hd: input_0,
                  tl: /* [] */0
                };
                var actual = Expr.Sequence.toFORMt(input);
                var expected = {
                  TAG: /* Mark */0,
                  _0: []
                };
                t.equal(actual, expected, "should be an empty Mark");
                
              }));
        t.test("given a sequence of empty expressions", (function (t) {
                var input_0 = [];
                var input_1 = {
                  hd: [],
                  tl: {
                    hd: [],
                    tl: /* [] */0
                  }
                };
                var input = {
                  hd: input_0,
                  tl: input_1
                };
                var actual = Expr.Sequence.toFORMt(input);
                var expected = {
                  TAG: /* Mark */0,
                  _0: [{
                      TAG: /* Mark */0,
                      _0: [{
                          TAG: /* Mark */0,
                          _0: []
                        }]
                    }]
                };
                t.equal(actual, expected, "should be 3 nested Marks");
                
              }));
        
      }));

export {
  exprsCon ,
  exprsVar ,
  dtrees ,
  
}
/* exprsCon Not a pure module */
