// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Zora from "zora";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as DNA$Formform from "../src/core/calc/DNA.bs.js";
import * as Expr$Formform from "../src/core/form/Expr.bs.js";

var exprsCon = [
  {
    f: [],
    str: ""
  },
  {
    f: [
      {
        TAG: /* Uncl */3,
        _0: ""
      },
      {
        TAG: /* Uncl */3,
        _0: "üëÄ"
      }
    ],
    str: "///üëÄ/"
  },
  {
    f: [{
        TAG: /* FDna */5,
        _0: {
          dna: DNA$Formform.makeUnsafe([/* N */0]),
          form: undefined,
          vars: undefined
        }
      }],
    str: "[‚Åò0]"
  },
  {
    f: [{
        TAG: /* Mark */0,
        _0: [
          {
            TAG: /* Mark */0,
            _0: []
          },
          {
            TAG: /* Mark */0,
            _0: [
              {
                TAG: /* Mark */0,
                _0: [{
                    TAG: /* Mark */0,
                    _0: []
                  }]
              },
              {
                TAG: /* Mark */0,
                _0: []
              }
            ]
          }
        ]
      }],
    str: "(()((())()))"
  },
  {
    f: [
      {
        TAG: /* Mark */0,
        _0: []
      },
      {
        TAG: /* CVal */1,
        _0: /* U */1
      },
      {
        TAG: /* Uncl */3,
        _0: "√úber Ich"
      },
      {
        TAG: /* SeqRE */2,
        _0: {
          reEntryPar: /* Any */2,
          unmarked: true,
          interpr: /* RecIdent */1
        },
        _1: {
          hd: [{
              TAG: /* Mark */0,
              _0: [{
                  TAG: /* CVal */1,
                  _0: /* M */3
                }]
            }],
          tl: {
            hd: [],
            tl: /* [] */0
          }
        }
      },
      {
        TAG: /* FDna */5,
        _0: {
          dna: DNA$Formform.makeUnsafe([
                /* M */3,
                /* I */2,
                /* U */1,
                /* N */0
              ]),
          form: [{
              TAG: /* CVal */1,
              _0: /* M */3
            }],
          vars: undefined
        }
      }
    ],
    str: "()U/√úber Ich/{@~_ ,(M)}[M‚Åò3210]"
  }
];

var exprsVar = [
  {
    f: [],
    str: ""
  },
  {
    f: [
      {
        TAG: /* FVar */4,
        _0: "a"
      },
      {
        TAG: /* FVar */4,
        _0: "Œª"
      },
      {
        TAG: /* FVar */4,
        _0: "a_n"
      },
      {
        TAG: /* FVar */4,
        _0: "apple"
      },
      {
        TAG: /* FVar */4,
        _0: "s√º√üer_apfel b"
      }
    ],
    str: "aŒªa_n\"apple\"\"s√º√üer_apfel b\""
  }
];

Zora.test("Testing show()", (function (t) {
        exprsCon.forEach(function (expr) {
              t.test("given a constant [FORM], test for \"" + expr.str + "\"", (function (t) {
                      var input = expr.f;
                      var actual = Expr$Formform.FORM.show(undefined, input);
                      var expected = expr.str;
                      t.equal(actual, expected, "should be the formula \"" + expr.str + "\"");
                      
                    }));
              
            });
        exprsVar.forEach(function (expr) {
              t.test("given a variable [FORM], test for \"" + expr.str + "\"", (function (t) {
                      var input = expr.f;
                      var actual = Expr$Formform.FORM.show(undefined, input);
                      var expected = expr.str;
                      t.equal(actual, expected, "should be the formula \"" + expr.str + "\"");
                      
                    }));
              
            });
        
      }));

var exprsCon$1 = [
  {
    f: [],
    fvar: []
  },
  {
    f: [
      {
        TAG: /* Mark */0,
        _0: [
          {
            TAG: /* CVal */1,
            _0: /* I */2
          },
          {
            TAG: /* Mark */0,
            _0: [{
                TAG: /* Mark */0,
                _0: [{
                    TAG: /* CVal */1,
                    _0: /* N */0
                  }]
              }]
          },
          {
            TAG: /* CVal */1,
            _0: /* U */1
          }
        ]
      },
      {
        TAG: /* SeqRE */2,
        _0: {
          reEntryPar: /* Even */0,
          unmarked: false,
          interpr: /* RecInstr */0
        },
        _1: {
          hd: [{
              TAG: /* Uncl */3,
              _0: "Unklar"
            }],
          tl: /* [] */0
        }
      },
      {
        TAG: /* FDna */5,
        _0: {
          dna: DNA$Formform.makeUnsafe([/* N */0]),
          form: [{
              TAG: /* CVal */1,
              _0: /* M */3
            }],
          vars: ["a"]
        }
      }
    ],
    fvar: [
      {
        TAG: /* Mark */0,
        _0: [
          {
            TAG: /* CVal */1,
            _0: /* I */2
          },
          {
            TAG: /* Mark */0,
            _0: [{
                TAG: /* Mark */0,
                _0: [{
                    TAG: /* CVal */1,
                    _0: /* N */0
                  }]
              }]
          },
          {
            TAG: /* CVal */1,
            _0: /* U */1
          }
        ]
      },
      {
        TAG: /* SeqRE */2,
        _0: {
          reEntryPar: /* Even */0,
          unmarked: false,
          interpr: /* RecInstr */0
        },
        _1: {
          hd: [{
              TAG: /* Uncl */3,
              _0: "Unklar"
            }],
          tl: /* [] */0
        }
      },
      {
        TAG: /* FDna */5,
        _0: {
          dna: DNA$Formform.makeUnsafe([/* N */0]),
          form: [{
              TAG: /* CVal */1,
              _0: /* M */3
            }],
          vars: ["a"]
        }
      }
    ]
  }
];

Zora.test("Testing FCON.toVarFORM", (function (t) {
        exprsCon$1.forEach(function (expr) {
              t.test("given an [ConstFORM] expression", (function (t) {
                      var input = expr.f;
                      var actual = Curry._1(Expr$Formform.FORM.ConstFORM.toVarFORM, input);
                      var expected = expr.fvar;
                      t.equal(actual, expected, "should be equivalent [VarFORM]");
                      
                    }));
              
            });
        
      }));

var exprsVar$1 = [
  {
    f: [],
    vars: [],
    count: 0
  },
  {
    f: [
      {
        TAG: /* Mark */0,
        _0: [{
            TAG: /* CVal */1,
            _0: /* U */1
          }]
      },
      {
        TAG: /* Uncl */3,
        _0: "Cthulu"
      }
    ],
    vars: [],
    count: 0
  },
  {
    f: [
      {
        TAG: /* Mark */0,
        _0: []
      },
      {
        TAG: /* Mark */0,
        _0: [{
            TAG: /* FVar */4,
            _0: "a"
          }]
      },
      {
        TAG: /* CVal */1,
        _0: /* M */3
      }
    ],
    vars: ["a"],
    count: 1
  },
  {
    f: [
      {
        TAG: /* Mark */0,
        _0: [{
            TAG: /* Mark */0,
            _0: [{
                TAG: /* FVar */4,
                _0: "Red"
              }]
          }]
      },
      {
        TAG: /* Mark */0,
        _0: [{
            TAG: /* FVar */4,
            _0: "Blue"
          }]
      },
      {
        TAG: /* FVar */4,
        _0: "Green"
      }
    ],
    vars: [
      "Blue",
      "Green",
      "Red"
    ],
    count: 3
  },
  {
    f: [{
        TAG: /* SeqRE */2,
        _0: {
          reEntryPar: /* Odd */1,
          unmarked: true,
          interpr: /* RecInstr */0
        },
        _1: {
          hd: [
            {
              TAG: /* FVar */4,
              _0: "M√§use"
            },
            {
              TAG: /* SeqRE */2,
              _0: {
                reEntryPar: /* Odd */1,
                unmarked: true,
                interpr: /* RecInstr */0
              },
              _1: {
                hd: [{
                    TAG: /* FVar */4,
                    _0: "Ratten"
                  }],
                tl: {
                  hd: [{
                      TAG: /* Mark */0,
                      _0: [{
                          TAG: /* FVar */4,
                          _0: "W√ºrmer"
                        }]
                    }],
                  tl: /* [] */0
                }
              }
            }
          ],
          tl: /* [] */0
        }
      }],
    vars: [
      "M√§use",
      "Ratten",
      "W√ºrmer"
    ],
    count: 3
  },
  {
    f: [{
        TAG: /* FDna */5,
        _0: {
          dna: DNA$Formform.makeUnsafe([/* N */0]),
          form: [
            {
              TAG: /* FVar */4,
              _0: "a"
            },
            {
              TAG: /* FVar */4,
              _0: "b"
            }
          ],
          vars: [
            "a",
            "b"
          ]
        }
      }],
    vars: [],
    count: 0
  }
];

Zora.test("Testing getVars()", (function (t) {
        exprsVar$1.forEach(function (expr) {
              t.test("given an [VarFORM] expression", (function (t) {
                      var input = expr.f;
                      var actual = Expr$Formform.FORM.getVars(input);
                      var expected = expr.vars;
                      t.equal(actual, expected, "should be \"" + expr.vars.toString() + "\"");
                      
                    }));
              
            });
        
      }));

Zora.test("Testing countVars()", (function (t) {
        exprsVar$1.forEach(function (expr) {
              t.test("given an [VarFORM] expression", (function (t) {
                      var input = expr.f;
                      var actual = Expr$Formform.FORM.countVars(input);
                      var expected = expr.count;
                      t.equal(actual, expected, "should be \"" + expr.count.toString() + "\"");
                      
                    }));
              
            });
        
      }));

var dtrees = [
  {
    tree: Caml_array.get(Expr$Formform.DepthTree.testTrees, 0),
    form: [],
    str: "{ root, form: '', children: [] }"
  },
  {
    tree: Caml_array.get(Expr$Formform.DepthTree.testTrees, 1),
    form: [{
        TAG: /* CVal */1,
        _0: /* U */1
      }],
    str: "{ root, form: 'U', children: [{ index: 0, form: 'U' }] }"
  },
  {
    tree: Caml_array.get(Expr$Formform.DepthTree.testTrees, 2),
    form: [{
        TAG: /* Mark */0,
        _0: []
      }],
    str: "{ root, form: '()', children: [{ index: 0, form: '()', children: [] }] }"
  },
  {
    tree: Caml_array.get(Expr$Formform.DepthTree.testTrees, 3),
    form: [{
        TAG: /* Mark */0,
        _0: [
          {
            TAG: /* CVal */1,
            _0: /* M */3
          },
          {
            TAG: /* Mark */0,
            _0: []
          }
        ]
      }],
    str: "{ root, form: '(M())', children: [{ index: 0, form: '(M())', children: [{ index: 00, form: 'M' }, { index: 01, form: '()', children: [] }] }] }"
  }
];

Zora.test("Testing DepthTree.parse()", (function (t) {
        dtrees.forEach(function (input) {
              t.test("given a depth tree", (function (t) {
                      var actual = Expr$Formform.DepthTree.parse(input.form);
                      var expected = input.tree;
                      t.equal(actual, expected, "should be \"" + input.str + "\"");
                      
                    }));
              
            });
        
      }));

Zora.test("Testing DepthTree.show()", (function (t) {
        dtrees.forEach(function (input) {
              t.test("given a depth tree", (function (t) {
                      var actual = Expr$Formform.DepthTree.show(input.tree);
                      var expected = input.str;
                      t.equal(actual, expected, "should be \"" + input.str + "\"");
                      
                    }));
              
            });
        
      }));

Zora.test("Testing Sequence.toFORMt()", (function (t) {
        t.test("given an empty sequence", (function (t) {
                var actual = Expr$Formform.Sequence.toFORMt(/* [] */0);
                var expected = {
                  TAG: /* Mark */0,
                  _0: []
                };
                t.equal(actual, expected, "should be an empty Mark");
                
              }));
        t.test("given a singleton sequence", (function (t) {
                var input_0 = [];
                var input = {
                  hd: input_0,
                  tl: /* [] */0
                };
                var actual = Expr$Formform.Sequence.toFORMt(input);
                var expected = {
                  TAG: /* Mark */0,
                  _0: []
                };
                t.equal(actual, expected, "should be an empty Mark");
                
              }));
        t.test("given a sequence of empty expressions", (function (t) {
                var input_0 = [];
                var input_1 = {
                  hd: [],
                  tl: {
                    hd: [],
                    tl: /* [] */0
                  }
                };
                var input = {
                  hd: input_0,
                  tl: input_1
                };
                var actual = Expr$Formform.Sequence.toFORMt(input);
                var expected = {
                  TAG: /* Mark */0,
                  _0: [{
                      TAG: /* Mark */0,
                      _0: [{
                          TAG: /* Mark */0,
                          _0: []
                        }]
                    }]
                };
                t.equal(actual, expected, "should be 3 nested Marks");
                
              }));
        
      }));

export {
  exprsCon$1 as exprsCon,
  exprsVar$1 as exprsVar,
  dtrees ,
  
}
/* exprsCon Not a pure module */
