// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Zora from "zora";
import * as DNA$Formform from "../src/core/calc/DNA.bs.js";
import * as Formula$Formform from "../src/core/form/Formula.bs.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var fml_samples = [
  {
    fml: "",
    tks: /* [] */0
  },
  {
    fml: " )( )  ( ",
    tks: {
      hd: {
        TAG: /* Mark */0,
        _0: /* Close */1
      },
      tl: {
        hd: {
          TAG: /* Mark */0,
          _0: /* Open */0
        },
        tl: {
          hd: {
            TAG: /* Mark */0,
            _0: /* Close */1
          },
          tl: {
            hd: {
              TAG: /* Mark */0,
              _0: /* Open */0
            },
            tl: /* [] */0
          }
        }
      }
    }
  },
  {
    fml: "(N((U )I)  )M",
    tks: {
      hd: {
        TAG: /* Mark */0,
        _0: /* Open */0
      },
      tl: {
        hd: {
          TAG: /* Const */2,
          _0: /* N */0
        },
        tl: {
          hd: {
            TAG: /* Mark */0,
            _0: /* Open */0
          },
          tl: {
            hd: {
              TAG: /* Mark */0,
              _0: /* Open */0
            },
            tl: {
              hd: {
                TAG: /* Const */2,
                _0: /* U */1
              },
              tl: {
                hd: {
                  TAG: /* Mark */0,
                  _0: /* Close */1
                },
                tl: {
                  hd: {
                    TAG: /* Const */2,
                    _0: /* I */2
                  },
                  tl: {
                    hd: {
                      TAG: /* Mark */0,
                      _0: /* Close */1
                    },
                    tl: {
                      hd: {
                        TAG: /* Mark */0,
                        _0: /* Close */1
                      },
                      tl: {
                        hd: {
                          TAG: /* Const */2,
                          _0: /* M */3
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  {
    fml: "aμ_2b_n\" süßer_apfel b\"(/b_1 n_+2 /\"42/4\")\")\"",
    tks: {
      hd: {
        TAG: /* Var */4,
        _0: "a"
      },
      tl: {
        hd: {
          TAG: /* Var */4,
          _0: "μ_2"
        },
        tl: {
          hd: {
            TAG: /* Var */4,
            _0: "b_n"
          },
          tl: {
            hd: {
              TAG: /* Var */4,
              _0: " süßer_apfel b"
            },
            tl: {
              hd: {
                TAG: /* Mark */0,
                _0: /* Open */0
              },
              tl: {
                hd: {
                  TAG: /* Uncl */5,
                  _0: "b_1 n_+2 "
                },
                tl: {
                  hd: {
                    TAG: /* Var */4,
                    _0: "42/4"
                  },
                  tl: {
                    hd: {
                      TAG: /* Mark */0,
                      _0: /* Close */1
                    },
                    tl: {
                      hd: {
                        TAG: /* Var */4,
                        _0: ")"
                      },
                      tl: /* [] */0
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  {
    fml: "\"_\"/a_/\"_a\"",
    tks: {
      hd: {
        TAG: /* Var */4,
        _0: "_"
      },
      tl: {
        hd: {
          TAG: /* Uncl */5,
          _0: "a_"
        },
        tl: {
          hd: {
            TAG: /* Var */4,
            _0: "_a"
          },
          tl: /* [] */0
        }
      }
    }
  },
  {
    fml: "::0123",
    tks: {
      hd: {
        TAG: /* DNA */8,
        sortNMUI: true,
        code: DNA$Formform.fromIntArrUnsafe(true, [
              0,
              1,
              2,
              3
            ])
      },
      tl: /* [] */0
    }
  },
  {
    fml: "⁘0123",
    tks: {
      hd: {
        TAG: /* DNA */8,
        sortNMUI: false,
        code: DNA$Formform.fromIntArrUnsafe(false, [
              0,
              1,
              2,
              3
            ])
      },
      tl: /* [] */0
    }
  }
];

var fml_invalid = [
  {
    fml: "\"",
    exn: "Closing '\"' is missing!"
  },
  {
    fml: "/",
    exn: "Closing '/' is missing!"
  },
  {
    fml: "\"a\"\"",
    exn: "Closing '\"' is missing!"
  },
  {
    fml: "/\"/a/",
    exn: "Closing '/' is missing!"
  },
  {
    fml: "//a\"/",
    exn: "Label should not be empty!"
  },
  {
    fml: "\"\"\"",
    exn: "Label should not be empty!"
  },
  {
    fml: "aA",
    exn: "Unable to interpret 'A'."
  },
  {
    fml: "0a",
    exn: "Unable to interpret '0'."
  }
];

Zora.test("Testing Lexer.scan", (function (t) {
        fml_samples.forEach(function (sample) {
              t.test("given a formula '" + sample.fml + "'", (function (t) {
                      var input = sample.fml;
                      var actual = Formula$Formform.Lexer.scan(input);
                      var expected = sample.tks;
                      t.equal(actual, expected, "should be a token stream");
                      
                    }));
              
            });
        fml_invalid.forEach(function (sample) {
              t.test("given an invalid formula '" + sample.fml + "'", (function (t) {
                      var input = sample.fml;
                      var expected = sample.exn;
                      var val;
                      try {
                        val = Formula$Formform.Lexer.scan(input);
                      }
                      catch (raw_exn){
                        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                        if (exn.RE_EXN_ID === Formula$Formform.Lexer.LexError) {
                          var msg = exn.msg;
                          t.equal(msg, expected, "should be \"" + expected + "\", but was \"" + msg + "\"");
                          return ;
                        }
                        throw exn;
                      }
                      t.fail("expected error, but scan successful");
                      
                    }));
              
            });
        
      }));

export {
  fml_samples ,
  fml_invalid ,
  
}
/* fml_samples Not a pure module */
